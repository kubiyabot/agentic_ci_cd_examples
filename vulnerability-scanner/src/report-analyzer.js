/**
 * Vulnerability Report Analyzer
 * Parses Trivy JSON output and provides structured analysis
 */

class VulnerabilityAnalyzer {
  constructor() {
    this.severityWeights = {
      CRITICAL: 10,
      HIGH: 7,
      MEDIUM: 4,
      LOW: 1,
      UNKNOWN: 0,
    };
  }

  /**
   * Parse Trivy JSON output
   */
  parseReport(reportJson) {
    if (!reportJson || !reportJson.Results) {
      return { vulnerabilities: [], summary: this.getEmptySummary() };
    }

    const vulnerabilities = [];

    for (const result of reportJson.Results) {
      if (!result.Vulnerabilities) continue;

      for (const vuln of result.Vulnerabilities) {
        vulnerabilities.push({
          id: vuln.VulnerabilityID,
          package: vuln.PkgName,
          installedVersion: vuln.InstalledVersion,
          fixedVersion: vuln.FixedVersion || null,
          severity: vuln.Severity,
          title: vuln.Title,
          description: vuln.Description,
          references: vuln.References || [],
          target: result.Target,
          hasFixAvailable: !!vuln.FixedVersion,
        });
      }
    }

    return {
      vulnerabilities,
      summary: this.calculateSummary(vulnerabilities),
    };
  }

  /**
   * Calculate vulnerability summary
   */
  calculateSummary(vulnerabilities) {
    const summary = {
      total: vulnerabilities.length,
      bySeverity: {
        CRITICAL: 0,
        HIGH: 0,
        MEDIUM: 0,
        LOW: 0,
        UNKNOWN: 0,
      },
      fixable: 0,
      unfixable: 0,
      riskScore: 0,
      packages: new Set(),
    };

    for (const vuln of vulnerabilities) {
      summary.bySeverity[vuln.severity] =
        (summary.bySeverity[vuln.severity] || 0) + 1;

      if (vuln.hasFixAvailable) {
        summary.fixable++;
      } else {
        summary.unfixable++;
      }

      summary.riskScore += this.severityWeights[vuln.severity] || 0;
      summary.packages.add(vuln.package);
    }

    summary.packages = Array.from(summary.packages);
    summary.uniquePackages = summary.packages.length;

    return summary;
  }

  /**
   * Generate fix recommendations
   */
  generateRecommendations(vulnerabilities) {
    const recommendations = [];
    const packageUpdates = new Map();

    // Group by package for consolidated updates
    for (const vuln of vulnerabilities) {
      if (vuln.hasFixAvailable) {
        const key = vuln.package;
        if (
          !packageUpdates.has(key) ||
          this.compareVersions(
            vuln.fixedVersion,
            packageUpdates.get(key).fixedVersion
          ) > 0
        ) {
          packageUpdates.set(key, {
            package: vuln.package,
            currentVersion: vuln.installedVersion,
            fixedVersion: vuln.fixedVersion,
            vulnerabilities: [],
            maxSeverity: vuln.severity,
          });
        }
        packageUpdates.get(key).vulnerabilities.push(vuln.id);
      }
    }

    // Generate update recommendations
    for (const [pkg, update] of packageUpdates) {
      recommendations.push({
        type: 'UPDATE',
        priority: this.severityWeights[update.maxSeverity],
        package: pkg,
        action: `npm install ${pkg}@${update.fixedVersion}`,
        fixes: update.vulnerabilities,
        severity: update.maxSeverity,
      });
    }

    // Sort by priority (highest first)
    recommendations.sort((a, b) => b.priority - a.priority);

    return recommendations;
  }

  /**
   * Simple version comparison
   */
  compareVersions(v1, v2) {
    if (!v1) return -1;
    if (!v2) return 1;
    const parts1 = v1.split('.').map((n) => parseInt(n, 10) || 0);
    const parts2 = v2.split('.').map((n) => parseInt(n, 10) || 0);

    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const p1 = parts1[i] || 0;
      const p2 = parts2[i] || 0;
      if (p1 > p2) return 1;
      if (p1 < p2) return -1;
    }
    return 0;
  }

  /**
   * Get empty summary structure
   */
  getEmptySummary() {
    return {
      total: 0,
      bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 },
      fixable: 0,
      unfixable: 0,
      riskScore: 0,
      packages: [],
      uniquePackages: 0,
    };
  }

  /**
   * Determine if scan should fail CI
   */
  shouldFailBuild(summary, thresholds = {}) {
    const defaults = {
      maxCritical: 0,
      maxHigh: 5,
      maxRiskScore: 50,
    };
    const config = { ...defaults, ...thresholds };

    if (summary.bySeverity.CRITICAL > config.maxCritical) {
      return {
        fail: true,
        reason: `Found ${summary.bySeverity.CRITICAL} CRITICAL vulnerabilities (max: ${config.maxCritical})`,
      };
    }

    if (summary.bySeverity.HIGH > config.maxHigh) {
      return {
        fail: true,
        reason: `Found ${summary.bySeverity.HIGH} HIGH vulnerabilities (max: ${config.maxHigh})`,
      };
    }

    if (summary.riskScore > config.maxRiskScore) {
      return {
        fail: true,
        reason: `Risk score ${summary.riskScore} exceeds maximum (${config.maxRiskScore})`,
      };
    }

    return { fail: false, reason: 'All thresholds passed' };
  }
}

/**
 * Generate package.json patch for fixing vulnerabilities
 */
function generatePackageJsonPatch(currentPackageJson, recommendations) {
  const updates = {};

  for (const rec of recommendations) {
    if (rec.type === 'UPDATE' && rec.fixedVersion) {
      updates[rec.package] = rec.fixedVersion;
    }
  }

  const patched = { ...currentPackageJson };

  if (patched.dependencies) {
    for (const [pkg, version] of Object.entries(updates)) {
      if (patched.dependencies[pkg]) {
        patched.dependencies[pkg] = version;
      }
    }
  }

  if (patched.devDependencies) {
    for (const [pkg, version] of Object.entries(updates)) {
      if (patched.devDependencies[pkg]) {
        patched.devDependencies[pkg] = version;
      }
    }
  }

  return patched;
}

module.exports = {
  VulnerabilityAnalyzer,
  generatePackageJsonPatch,
};
