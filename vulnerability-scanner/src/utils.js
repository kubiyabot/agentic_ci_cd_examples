/**
 * Utility functions for vulnerability scanning
 */

/**
 * Format vulnerability for display
 */
function formatVulnerability(vuln) {
  const fixStatus = vuln.hasFixAvailable
    ? `Fix: ${vuln.fixedVersion}`
    : 'No fix available';

  return {
    display: `[${vuln.severity}] ${vuln.id} in ${vuln.package}@${vuln.installedVersion} - ${fixStatus}`,
    shortDisplay: `${vuln.id}: ${vuln.package} (${vuln.severity})`,
  };
}

/**
 * Group vulnerabilities by severity
 */
function groupBySeverity(vulnerabilities) {
  const groups = {
    CRITICAL: [],
    HIGH: [],
    MEDIUM: [],
    LOW: [],
    UNKNOWN: [],
  };

  for (const vuln of vulnerabilities) {
    const severity = vuln.severity || 'UNKNOWN';
    if (groups[severity]) {
      groups[severity].push(vuln);
    } else {
      groups.UNKNOWN.push(vuln);
    }
  }

  return groups;
}

/**
 * Filter vulnerabilities by criteria
 */
function filterVulnerabilities(vulnerabilities, filters = {}) {
  return vulnerabilities.filter((vuln) => {
    if (filters.minSeverity) {
      const severityOrder = ['UNKNOWN', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
      const vulnIndex = severityOrder.indexOf(vuln.severity);
      const minIndex = severityOrder.indexOf(filters.minSeverity);
      if (vulnIndex < minIndex) return false;
    }

    if (filters.fixableOnly && !vuln.hasFixAvailable) {
      return false;
    }

    if (filters.packages && filters.packages.length > 0) {
      if (!filters.packages.includes(vuln.package)) return false;
    }

    return true;
  });
}

/**
 * Generate markdown report
 */
function generateMarkdownReport(analysis) {
  const { vulnerabilities, summary } = analysis;
  let md = '# Vulnerability Scan Report\n\n';

  md += '## Summary\n\n';
  md += `| Metric | Value |\n`;
  md += `|--------|-------|\n`;
  md += `| Total Vulnerabilities | ${summary.total} |\n`;
  md += `| Critical | ${summary.bySeverity.CRITICAL} |\n`;
  md += `| High | ${summary.bySeverity.HIGH} |\n`;
  md += `| Medium | ${summary.bySeverity.MEDIUM} |\n`;
  md += `| Low | ${summary.bySeverity.LOW} |\n`;
  md += `| Fixable | ${summary.fixable} |\n`;
  md += `| Risk Score | ${summary.riskScore} |\n\n`;

  if (summary.bySeverity.CRITICAL > 0 || summary.bySeverity.HIGH > 0) {
    md += '## Critical & High Severity Issues\n\n';
    const critical = vulnerabilities.filter(
      (v) => v.severity === 'CRITICAL' || v.severity === 'HIGH'
    );

    for (const vuln of critical) {
      md += `### ${vuln.id}\n\n`;
      md += `- **Package**: ${vuln.package}@${vuln.installedVersion}\n`;
      md += `- **Severity**: ${vuln.severity}\n`;
      md += `- **Fix Available**: ${vuln.hasFixAvailable ? vuln.fixedVersion : 'No'}\n`;
      md += `- **Title**: ${vuln.title || 'N/A'}\n\n`;
    }
  }

  return md;
}

/**
 * Calculate risk delta between two scans
 */
function calculateRiskDelta(currentSummary, previousSummary) {
  if (!previousSummary) {
    return {
      totalDelta: currentSummary.total,
      riskDelta: currentSummary.riskScore,
      newVulnerabilities: currentSummary.total,
      fixedVulnerabilities: 0,
      trend: 'BASELINE',
    };
  }

  const totalDelta = currentSummary.total - previousSummary.total;
  const riskDelta = currentSummary.riskScore - previousSummary.riskScore;

  let trend = 'STABLE';
  if (riskDelta > 10) trend = 'DEGRADED';
  else if (riskDelta < -10) trend = 'IMPROVED';

  return {
    totalDelta,
    riskDelta,
    trend,
    severityChanges: {
      CRITICAL:
        currentSummary.bySeverity.CRITICAL - previousSummary.bySeverity.CRITICAL,
      HIGH: currentSummary.bySeverity.HIGH - previousSummary.bySeverity.HIGH,
      MEDIUM:
        currentSummary.bySeverity.MEDIUM - previousSummary.bySeverity.MEDIUM,
      LOW: currentSummary.bySeverity.LOW - previousSummary.bySeverity.LOW,
    },
  };
}

module.exports = {
  formatVulnerability,
  groupBySeverity,
  filterVulnerabilities,
  generateMarkdownReport,
  calculateRiskDelta,
};
