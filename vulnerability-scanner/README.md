# Vulnerability Scanner - Agentic Security Scanning

This use case demonstrates **intelligent vulnerability scanning** using Kubiya's agentic CI/CD capabilities. Unlike traditional scanners that simply output findings, this approach leverages an AI agent that:

- **Recalls** past vulnerability history and remediation patterns from organizational memory
- **Analyzes** scan results with context and historical awareness
- **Prioritizes** fixes based on severity, exploitability, and organizational patterns
- **Creates PRs** with automated dependency patches
- **Stores** learnings for continuous improvement across the organization

## How It Works

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          GitHub Actions Workflow                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. Install Security Tools (Trivy, npm audit, etc.)                        │
│                           ↓                                                  │
│  2. Kubiya Agent Executes with Full Pipeline Access                        │
│     ┌─────────────────────────────────────────────────────────────────┐    │
│     │  PHASE 1: Recall organizational memory                          │    │
│     │    - Previous scan history for this repo                        │    │
│     │    - Known false positives                                       │    │
│     │    - Successful remediation patterns                            │    │
│     │                                                                  │    │
│     │  PHASE 2: Execute comprehensive scans                           │    │
│     │    - trivy fs . --format json                                   │    │
│     │    - npm audit --json                                           │    │
│     │    - Secrets pattern detection                                  │    │
│     │                                                                  │    │
│     │  PHASE 3: Analyze with historical context                       │    │
│     │    - Categorize by severity                                      │    │
│     │    - Identify NEW vs RECURRING issues                           │    │
│     │    - Calculate risk scores                                       │    │
│     │                                                                  │    │
│     │  PHASE 4: Generate remediation plan                             │    │
│     │    - Prioritized fix commands                                    │    │
│     │    - Code change suggestions                                     │    │
│     │                                                                  │    │
│     │  PHASE 5: Create fix PR (if critical issues)                    │    │
│     │    - Update package.json with fixed versions                    │    │
│     │    - Commit, push, and create PR via gh CLI                     │    │
│     │                                                                  │    │
│     │  PHASE 6: Store learnings to memory                             │    │
│     │    - Scan results for trend analysis                            │    │
│     │    - New remediation patterns discovered                        │    │
│     │                                                                  │    │
│     │  PHASE 7: Report summary with CI decision                       │    │
│     └─────────────────────────────────────────────────────────────────┘    │
│                           ↓                                                  │
│  3. Run Tests & Upload Artifacts                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Key Features

### 1. Organizational Memory Integration

The agent leverages Kubiya's memory system to:

```javascript
// Recall past vulnerabilities
recall_memory('vulnerability scan history for this repository')
recall_memory('security remediation patterns')

// Store new findings
store_memory({
  dataset: 'vulnerability-scan-history',
  content: 'Scan results summary',
  metadata: {
    repository: 'org/repo',
    risk_score: 45,
    critical_count: 0,
    high_count: 3
  }
})
```

### 2. Automated PR Creation

When critical vulnerabilities with available fixes are detected, the agent:

1. Creates a new branch
2. Updates `package.json` with fixed versions
3. Commits changes with detailed CVE information
4. Creates a PR via GitHub CLI

### 3. Contextual Analysis

Unlike basic scanners, the agent:

- Identifies **NEW** vulnerabilities vs **RECURRING** issues
- Detects **REGRESSIONS** (previously fixed, now reintroduced)
- Applies organizational patterns to reduce false positives
- Provides trend analysis (improving/degrading/stable)

### 4. Risk-Based CI Decisions

```
PASS: No CRITICAL, ≤5 HIGH, risk score < 50
WARN: Some HIGH vulnerabilities but manageable
FAIL: CRITICAL vulnerabilities or risk score > 100
```

## Project Structure

```
vulnerability-scanner/
├── .github/
│   └── workflows/
│       └── vulnerability-scan.yml   # GitHub Actions workflow
├── src/
│   ├── index.js                     # Example app with vulnerabilities
│   ├── report-analyzer.js           # Trivy output parser
│   └── utils.js                     # Helper utilities
├── __tests__/
│   └── unit/
│       ├── report-analyzer.test.js
│       └── utils.test.js
├── package.json                     # Intentionally vulnerable deps
├── jest.config.js
└── README.md
```

## Example Vulnerable Dependencies

The `package.json` includes intentionally vulnerable packages for demonstration:

| Package | Version | Vulnerability |
|---------|---------|---------------|
| lodash | 4.17.20 | Prototype Pollution (CVE-2020-8203) |
| axios | 0.21.1 | ReDoS (CVE-2021-3749) |
| express | 4.17.1 | Multiple issues |
| jsonwebtoken | 8.5.1 | Security issues |
| node-fetch | 2.6.1 | Header exposure |
| serialize-javascript | 4.0.0 | XSS vulnerability |

## Running Locally

### Run Tests
```bash
cd vulnerability-scanner
npm install
npm test
```

### Manual Trivy Scan
```bash
# Install Trivy (macOS)
brew install trivy

# Run scan
trivy fs . --severity HIGH,CRITICAL
```

### With Kubiya CLI
```bash
# Install Kubiya CLI
curl -fsSL https://cli.kubiya.ai/install.sh | bash

# Run intelligent scan
kubiya exec "Scan this directory for vulnerabilities using trivy, analyze the results, and suggest fixes" --local --cwd .
```

## Memory Datasets

The agent uses these memory datasets:

| Dataset | Purpose |
|---------|---------|
| `vulnerability-scan-history` | Track scan results over time |
| `security-remediation-patterns` | Successful fix patterns |
| `security-false-positives` | Known false positives to ignore |
| `security-policies` | Organizational security thresholds |

## Workflow Configuration

### Required Secrets

- `KUBIYA_API_KEY`: Your Kubiya API key
- `GITHUB_TOKEN`: Automatically provided (for PR creation)

### Triggers

The workflow runs on:
- Push to `vulnerability-scanner/**`
- Pull requests affecting `vulnerability-scanner/**`
- Manual dispatch

## Comparison: Baseline vs Intelligent

| Aspect | Baseline Scan | Intelligent Scan |
|--------|--------------|------------------|
| Tool Execution | Static commands | Dynamic, context-aware |
| Analysis | Raw output | Categorized with history |
| Remediation | Manual | Automated PR creation |
| Learning | None | Stores patterns to memory |
| False Positives | All reported | Filtered by org knowledge |
| Trend Detection | None | Compares with history |

## Best Practices

1. **Memory Hygiene**: Periodically review stored patterns
2. **Threshold Tuning**: Adjust risk thresholds per repository
3. **PR Review**: Always review auto-generated fix PRs
4. **Incremental Fixes**: Don't fix everything at once - prioritize

## Related Use Cases

- [Incident Learning Pipeline](../incident-learning-pipeline/) - Learn from CI failures
- [Build Artifact Analyzer](../build-artifact-analyzer/) - Analyze build outputs
- [Cross-Repo Knowledge Share](../cross-repo-knowledge-share/) - Org-wide patterns
